'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var compositionApi = require('@vue/composition-api');

function _typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  }
}

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

function unwrap(val) {
  return compositionApi.isRef(val) ? val.value : val;
}
function unwrapObj(obj) {
  var ignoreKeys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  return Object.keys(obj).reduce(function (o, k) {
    if (ignoreKeys.includes(k)) return o;
    o[k] = unwrap(obj[k]);
    return o;
  }, {});
}
function isFunction(val) {
  return typeof val === 'function';
}
function isObject(val) {
  return val !== null && (_typeof(val) === 'object' || isFunction(val));
}
function isPromise(object) {
  return isObject(object) && isFunction(object.then);
}

function useVuelidate(validationsArg, state, registerAs) {
  var validations = unwrap(validationsArg); //
  // const childResults = ref({})
  //
  // const injectToParent = inject(VuelidateSymbol, () => {})
  // // const childResults = computed(() => {
  // //   return childValidationsKeys.value.reduce((res, key, index) => {
  // //     res[key] = childValidationsResults.value[index]
  // //     console.log('res', res)
  // //     return res
  // //   }, {})
  // // })
  //
  // function injectChildResults (results, key) {
  //   childResults.value[key] = results
  //   console.log('saving', key)
  // }
  //
  // provide(VuelidateSymbol, injectChildResults)

  var validationResults = setValidations({
    validations: validations,
    state: state // childResults

  }); // if (registerAs) {
  //   injectToParent(validationResults, registerAs)
  // }

  return validationResults;
}

function sortValidations(validations) {
  var validationKeys = Object.keys(validations);
  var rules = {};
  var nested = {};
  var config = {};
  validationKeys.forEach(function (key) {
    var v = validations[key];

    switch (true) {
      // If it is already normalized, use it
      case isFunction(v.$validator):
        rules[key] = v;
        break;
      // If it is just a function, normalize it first
      // into { $validator: <Fun> }

      case isFunction(v):
        rules[key] = {
          $validator: v
        };
        break;
      // Catch $-prefixed properties as config

      case key.startsWith('$'):
        config[key] = v;
        break;
      // If it doesn’t match any of the above,
      // treat as nested state property

      default:
        nested[key] = v;
    }
  });
  return {
    rules: rules,
    nested: nested,
    config: config
  };
}

function callRule(rule, value) {
  var v = unwrap(value);
  return rule(v);
}

function createComputedResult(rule, model) {
  return compositionApi.computed(function () {
    var result = callRule(rule, model);
    return result.$invalid !== undefined ? result.$invalid : !result;
  });
}

function createAsyncResult(rule, model, initResult, $pending) {
  var $invalid = compositionApi.ref(true);
  $pending.value = true;
  initResult.then(function (data) {
    $pending.value = false;
    $invalid.value = !data;
  });
  compositionApi.watch(model, function (modelValue) {
    var ruleResult = callRule(rule, modelValue);
    $pending.value = true;
    $invalid.value = true;
    ruleResult.then(function (data) {
      $pending.value = false;
      $invalid.value = !data;
    })["catch"](function () {
      $pending.value = false;
      $invalid.value = true;
    });
  }, {
    lazy: true
  });
  return $invalid;
}

function createValidatorResult(rule, model) {
  var ruleResult = callRule(rule.$validator, model);
  var $pending = compositionApi.ref(false);
  var $params = rule.$params;
  var $invalid = isPromise(ruleResult) ? createAsyncResult(rule.$validator, model, ruleResult, $pending) : createComputedResult(rule.$validator, model);
  var message = rule.$message;
  var $message = isFunction(message) ? compositionApi.computed(function () {
    return message(unwrapObj({
      $pending: $pending,
      $invalid: $invalid,
      $params: $params,
      $model: model
    }));
  }) : message;
  return {
    $message: $message,
    $params: $params,
    $pending: $pending,
    $invalid: $invalid
  };
}

function createValidationResults(rules, state, key, parentKey) {
  var ruleKeys = Object.keys(rules);
  if (!ruleKeys.length) return {};
  var $dirty = compositionApi.ref(false);
  var result = {
    $dirty: $dirty,
    $touch: function $touch() {
      $dirty.value = true;
    },
    $reset: function $reset() {
      $dirty.value = false;
    },
    $pending: compositionApi.ref(false)
  };
  ruleKeys.forEach(function (ruleKey) {
    result[ruleKey] = createValidatorResult(rules[ruleKey], state[key]);
  });
  result.$invalid = compositionApi.computed(function () {
    return ruleKeys.some(function (ruleKey) {
      return result[ruleKey].$invalid;
    });
  });
  result.$error = compositionApi.computed(function () {
    return result.$invalid.value && $dirty.value;
  });
  result.$errors = compositionApi.computed(function () {
    return ruleKeys.filter(function (ruleKey) {
      return unwrap(result[ruleKey]).$invalid;
    }).map(function (ruleKey) {
      var res = result[ruleKey];
      return {
        $property: parentKey ? "".concat(parentKey, ".").concat(key) : key,
        $validator: ruleKey,
        $message: res.$message,
        $params: res.$params,
        $pending: res.$pending
      };
    });
  });
  return result;
}

function collectNestedValidationResults(validations, state, key) {
  var nestedValidationKeys = Object.keys(validations);
  if (!nestedValidationKeys.length) return {};
  return nestedValidationKeys.reduce(function (results, nestedKey) {
    var nestedState = key ? state[key] : state;
    results[nestedKey] = setValidations({
      validations: validations[nestedKey],
      state: nestedState,
      key: nestedKey,
      parentKey: key
    });
    return results;
  }, {});
}

function createMetaFields(results, nestedResults) {
  var $dirty = compositionApi.ref(false);
  var $errors = compositionApi.computed(function () {
    var modelErrors = unwrap(results.$errors) || [];
    var nestedErrors = Object.values(nestedResults).filter(function (result) {
      return result.$errors.length;
    }).reduce(function (errors, result) {
      return errors.concat.apply(errors, _toConsumableArray(result.$errors));
    }, []);
    return modelErrors.concat(nestedErrors);
  });
  var $invalid = compositionApi.computed(function () {
    return Object.values(nestedResults).some(function (r) {
      return r.$invalid;
    }) || unwrap(results.$invalid) || false;
  });
  var $anyDirty = compositionApi.computed(function () {
    return Object.values(nestedResults).some(function (r) {
      return r.$dirty;
    });
  });
  var $error = compositionApi.computed(function () {
    return $invalid.value && $dirty.value || false;
  });
  return {
    $dirty: $dirty,
    $errors: $errors,
    $invalid: $invalid,
    $anyDirty: $anyDirty,
    $error: $error
  };
}

function setValidations(_ref) {
  var validations = _ref.validations,
      state = _ref.state,
      key = _ref.key,
      parentKey = _ref.parentKey,
      childResults = _ref.childResults;

  // Sort out the validation object into:
  // – rules = validators for current state tree fragment
  // — nested = nested state fragments keys that might contain more validators
  // – config = configuration properties that affect this state fragment
  var _sortValidations = sortValidations(validations),
      rules = _sortValidations.rules,
      nested = _sortValidations.nested,
      config = _sortValidations.config; // Use rules for the current state fragment and validate it


  var results = createValidationResults(rules, state, key, parentKey); // Use nested keys to repeat the process
  // *WARN*: This is recursive

  var nestedResults = collectNestedValidationResults(nested, state, key); // Collect and merge this level validation results
  // with all nested validation results

  var _createMetaFields = createMetaFields(results, nestedResults),
      $dirty = _createMetaFields.$dirty,
      $errors = _createMetaFields.$errors,
      $invalid = _createMetaFields.$invalid,
      $anyDirty = _createMetaFields.$anyDirty,
      $error = _createMetaFields.$error;

  var $model = compositionApi.computed({
    get: function get() {
      return unwrap(state[key]);
    },
    set: function set(val) {
      $dirty.value = true;
      state[key].value = val;
    }
  });

  if (config.$autoDirty) {
    compositionApi.watch(state[key], function () {
      $dirty.value = true;
    }, {
      lazy: true
    });
  }

  return compositionApi.reactive(Object.assign({}, results, {}, key ? {
    $model: $model
  } : {}, {
    $dirty: $dirty,
    $error: $error,
    $errors: $errors,
    $invalid: $invalid,
    $anyDirty: $anyDirty
  }, nestedResults));
}

function VuelidatePlugin(app) {
  app.mixin(VuelidateMixin);
}
var VuelidateMixin = {
  beforeCreate: function beforeCreate() {
    var _this = this;

    var options = this.$options;
    if (!options.validations) return;
    var validations = isFunction(options.validations) ? options.validations.call(this) : options.validations;
    if (!options.computed) options.computed = {};
    if (options.computed.$v) return;

    options.computed.$v = function () {
      return setValidations({
        validations: validations,
        state: _this
      });
    };
  }
};

exports.VuelidateMixin = VuelidateMixin;
exports.VuelidatePlugin = VuelidatePlugin;
exports.default = useVuelidate;
